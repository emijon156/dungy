# -*- coding: utf-8 -*-
"""dark dungy matter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aT22o3C1hEuO7wkpLXZabRf5ZmNt7MTz
"""


from datascience import *

expl_raw = Table.read_table('expl.csv').where('default_flag', 1)
expl_tbl = expl_raw.select('pl_name', 'hostname', 'pl_bmasse', 'ra', 'dec', 'sy_dist')
expl_tbl.show(5)

ra = expl_tbl.column('ra')
dec = expl_tbl.column('dec')
dist = expl_tbl.column('sy_dist')

from astropy.coordinates import SkyCoord
import astropy.units as u
import numpy as np
import streamlit as st


coords = SkyCoord(
    ra=np.array(ra) * u.deg,
    dec=np.array(dec) * u.deg,
    distance=np.array(dist) * u.parsec,
    frame='icrs'
)

galactocentric_coords = coords.transform_to('galactocentric')

expl_coord = expl_tbl.with_columns([
    'galactocentric_x', galactocentric_coords.x.value,
    'galactocentric_y', galactocentric_coords.y.value,
    'galactocentric_z', galactocentric_coords.z.value
])

x_coord = np.round(galactocentric_coords.x.value, 2)
y_coord = np.round(galactocentric_coords.y.value, 2)
z_coord = np.round(galactocentric_coords.z.value, 2)

i = 0
coordinate = []
while i <= expl_tbl.num_rows - 1:
  single_coordinate = f'({x_coord[i]}, {y_coord[i]}, {z_coord[i]})'
  coordinate.append(single_coordinate)
  i += 1

expl_coord = expl_coord.with_column('coordinate', coordinate)
expl_coord.show(5)

r_galactic = np.sqrt(
    np.array(expl_coord.column('galactocentric_x'))**2 +
    np.array(expl_coord.column('galactocentric_y'))**2 +
    np.array(expl_coord.column('galactocentric_z'))**2
)

expl_coord = expl_coord.with_column('r_galactic', r_galactic)
expl_coord.show(5)

rho_0 = 0.0106
R_s = 12500

r_over_Rs = r_galactic / R_s
dark_matter_density = rho_0 / (r_over_Rs * (1 + r_over_Rs)**2)

expl_coord = expl_coord.with_column('dark_matter_density', dark_matter_density)
expl_coord.show(5)

nan_test = np.isnan(expl_coord.column('pl_bmasse'))
expl_analysis = expl_coord.with_column('nan', nan_test).where('nan', False).drop('nan')
print(expl_coord.num_rows, expl_analysis.num_rows)

median_density = np.median(expl_analysis.column('dark_matter_density'))
region = ['Galactic Core' if dm >= median_density else 'Galactic Rim'
          for dm in expl_analysis.column('dark_matter_density')]

expl_analysis = expl_analysis.with_column('region', region)

nan_test = np.isnan(expl_raw.column('pl_bmasse'))
expl_all = expl_raw.with_column('nan', nan_test).where('nan', False).drop('nan')
expl_all

import pandas as pd
import numpy as np
from astropy.coordinates import SkyCoord
import astropy.units as u
from scipy.stats import spearmanr, linregress, pearsonr, kendalltau
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.cluster import DBSCAN
import statsmodels.api as sm
from statsmodels.formula.api import ols
import warnings
import scipy.stats as stats

warnings.filterwarnings('ignore')

df = pd.read_csv('expl.csv')
df_clean = df.dropna(subset=['ra', 'dec', 'sy_dist']).copy()

coords = SkyCoord(
    ra=df_clean['ra'].values*u.deg,
    dec=df_clean['dec'].values*u.deg,
    distance=df_clean['sy_dist'].values*u.pc,
    frame='icrs'
)
gal_coords = coords.transform_to('galactocentric')
df_clean['galactocentric_x'] = gal_coords.x.value
df_clean['galactocentric_y'] = gal_coords.y.value
df_clean['galactocentric_z'] = gal_coords.z.value

df_clean['r_galactic'] = np.sqrt(
    df_clean['galactocentric_x']**2 +
    df_clean['galactocentric_y']**2 +
    df_clean['galactocentric_z']**2
)

rho_0 = 0.0106
R_s = 12500
r_over_Rs = df_clean['r_galactic'] / R_s
df_clean['dark_matter_density'] = rho_0 / (r_over_Rs * (1 + r_over_Rs)**2)
df_clean['log_dm_density'] = np.log10(df_clean['dark_matter_density'])

planet_cols = ['pl_orbper', 'pl_orbsmax', 'pl_orbeccen', 'pl_bmasse', 'pl_rade']
df_planets = df_clean.dropna(subset=planet_cols).copy()

print(f"Working with {len(df_planets)} planets with complete properties")

print("=== 1. MULTIVARIATE ANALYSIS ===")

df_planets['dm_r_interaction'] = df_planets['log_dm_density'] * df_planets['r_galactic']
df_planets['dm_squared'] = df_planets['log_dm_density']**2
df_planets['r_squared'] = df_planets['r_galactic']**2

scaler = StandardScaler()
scaled_features = scaler.fit_transform(df_planets[['log_dm_density', 'r_galactic',
                                                  'pl_orbper', 'pl_bmasse']])
df_planets[['dm_scaled', 'r_scaled', 'period_scaled', 'mass_scaled']] = scaled_features

model = ols('period_scaled ~ dm_scaled + r_scaled + mass_scaled + dm_scaled:r_scaled',
            data=df_planets).fit()
print(model.summary())

print("\n=== 2. STRATIFIED ANALYSIS BY PLANET TYPE ===")

df_planets['mass_category'] = pd.cut(df_planets['pl_bmasse'],
                                    bins=[0, 10, 100, 1000, 10000],
                                    labels=['Earth-like', 'Neptune-like', 'Jupiter-like', 'Super-Jupiter'])

df_planets['period_category'] = pd.cut(df_planets['pl_orbper'],
                                      bins=[0, 10, 100, 1000, 10000],
                                      labels=['Short', 'Medium', 'Long', 'Very Long'])

results = []
for mass_cat in df_planets['mass_category'].unique():
    for period_cat in df_planets['period_category'].unique():
        subset = df_planets[(df_planets['mass_category'] == mass_cat) &
                           (df_planets['period_category'] == period_cat)]

        if len(subset) > 20:  # Minimum sample size
            corr, pval = spearmanr(subset['pl_orbper'], subset['log_dm_density'])
            results.append({
                'mass_category': mass_cat,
                'period_category': period_cat,
                'sample_size': len(subset),
                'spearman_r': corr,
                'p_value': pval
            })

results_df = pd.DataFrame(results)
print("Stratified analysis results:")
print(results_df.sort_values('p_value').head(10))

print("\n=== 3. ALTERNATIVE CORRELATION METHODS ===")

tau, pval_tau = kendalltau(df_planets['pl_orbper'], df_planets['log_dm_density'])
print(f"Kendall's tau: {tau:.4f}, p-value: {pval_tau:.4f}")

def partial_correlation(x, y, z):
    """Calculate partial correlation between x and y controlling for z"""
    x_res = sm.OLS(x, sm.add_constant(z)).fit().resid
    y_res = sm.OLS(y, sm.add_constant(z)).fit().resid
    return pearsonr(x_res, y_res)[0]

part_corr = partial_correlation(df_planets['pl_orbper'],
                               df_planets['log_dm_density'],
                               df_planets['r_galactic'])
print(f"Partial correlation (controlling for distance): {part_corr:.4f}")

print("\n=== 4. CLUSTERING ANALYSIS ===")

cluster_data = df_planets[['log_dm_density', 'r_galactic', 'pl_orbper', 'pl_bmasse']].dropna()
cluster_data_scaled = StandardScaler().fit_transform(cluster_data)

dbscan = DBSCAN(eps=0.5, min_samples=10)
clusters = dbscan.fit_predict(cluster_data_scaled)
df_planets.loc[cluster_data.index, 'cluster'] = clusters

if len(np.unique(clusters)) > 1:
    cluster_stats = df_planets.groupby('cluster').agg({
        'log_dm_density': ['mean', 'std'],
        'pl_orbper': ['mean', 'std'],
        'pl_bmasse': ['mean', 'std'],
        'r_galactic': ['mean', 'std']
    }).round(3)
    print("Cluster characteristics:")
    print(cluster_stats)

print("\n=== 5. BAYESIAN CORRELATION ANALYSIS ===")

def bayesian_correlation(x, y, n_iter=1000):
    """Simple Bayesian correlation estimation using bootstrap"""
    corrs = []
    for _ in range(n_iter):
        sample_idx = np.random.choice(len(x), size=len(x), replace=True)
        x_sample = x.iloc[sample_idx]
        y_sample = y.iloc[sample_idx]
        if len(x_sample) > 10:
            corr, _ = spearmanr(x_sample, y_sample)
            if not np.isnan(corr):
                corrs.append(corr)

    return np.mean(corrs), np.std(corrs)

bayes_mean, bayes_std = bayesian_correlation(df_planets['pl_orbper'],
                                           df_planets['log_dm_density'])
print(f"Bayesian correlation estimate: {bayes_mean:.4f} ± {bayes_std:.4f}")

print("\n=== 6. SPATIAL AUTOCORRELATION ===")

model_residuals = sm.OLS(df_planets['pl_orbper'],
                        sm.add_constant(df_planets[['log_dm_density', 'r_galactic']])).fit().resid

def morans_i(residuals, coords):
    """Calculate simplified Moran's I for spatial autocorrelation"""
    n = len(residuals)
    mean_res = np.mean(residuals)

    dist_matrix = np.sqrt(np.sum((coords[:, np.newaxis] - coords)**2, axis=2))
    np.fill_diagonal(dist_matrix, np.inf)  # Exclude self
    weights = 1 / dist_matrix
    weights[np.isinf(weights)] = 0 # Handle infinite weights
    weights = weights / np.sum(weights)

    numerator = np.sum(weights * (residuals - mean_res)[:, np.newaxis] * (residuals - mean_res))
    denominator = np.sum((residuals - mean_res)**2)

    if denominator == 0:
        return np.nan
    else:
        return (n / np.sum(weights)) * (numerator / denominator)


coords_array = df_planets[['galactocentric_x', 'galactocentric_y', 'galactocentric_z']].values
moran_i = morans_i(model_residuals.values, coords_array)
print(f"Moran's I (spatial autocorrelation): {moran_i:.4f}")

print("\n=== 7. ADVANCED VISUALIZATION ===")

plt.figure(figsize=(15, 10))

ax = plt.subplot(2, 2, 1, projection='3d')
scatter = ax.scatter(df_planets['r_galactic'], df_planets['log_dm_density'],
                    df_planets['pl_orbper'], c=df_planets['pl_bmasse'],
                    cmap='viridis', alpha=0.6)
ax.set_xlabel('Galactic Radius (pc)')
ax.set_ylabel('log(DM Density)')
ax.set_zlabel('Orbital Period (days)')
plt.colorbar(scatter, label='Planet Mass (Earth masses)')

plt.subplot(2, 2, 2)
hb = plt.hexbin(df_planets['log_dm_density'], df_planets['pl_orbper'],
                gridsize=30, cmap='Blues', mincnt=1)
plt.xlabel('log(DM Density)')
plt.ylabel('Orbital Period (days)')
plt.colorbar(hb, label='Count')

plt.subplot(2, 2, 3)
for mass_cat in df_planets['mass_category'].unique():
    subset = df_planets[df_planets['mass_category'] == mass_cat]
    if len(subset) > 30:
        plt.scatter(subset['log_dm_density'], subset['pl_orbper'],
                   alpha=0.6, label=mass_cat, s=30)
plt.xlabel('log(DM Density)')
plt.ylabel('Orbital Period (days)')
plt.legend()
plt.yscale('log')

plt.subplot(2, 2, 4)
plt.scatter(df_planets['log_dm_density'], model_residuals, alpha=0.6)
plt.axhline(y=0, color='r', linestyle='--')
plt.xlabel('log(DM Density)')
plt.ylabel('Residuals (Orbital Period)')

plt.tight_layout()
plt.show()

print("\n=== 8. POWER ANALYSIS ===")

def power_analysis(corr, n, alpha=0.05):
    """Calculate power for correlation analysis"""
    effect_size = np.abs(corr)

    ncp = effect_size * np.sqrt(n - 2) / np.sqrt(1 - effect_size**2)

    t_crit = stats.t.ppf(1 - alpha/2, n-2)

    power = 1 - stats.t.cdf(t_crit, n-2, ncp) + stats.t.cdf(-t_crit, n-2, ncp)
    return power

current_power = power_analysis(0.07, len(df_planets))
print(f"Power to detect r=0.07 with n={len(df_planets)}: {current_power:.3f}")

for effect_size in [0.1, 0.15, 0.2]:
    power = power_analysis(effect_size, len(df_planets))
    print(f"Power to detect r={effect_size}: {power:.3f}")

print("\n=== RECOMMENDATIONS ===")
print("1. The weak correlations (r ≈ 0.07) suggest any DM effect is very subtle")
print("2. Focus on specific planet subtypes where effects might be stronger")
print("3. Consider system-level properties rather than individual planets")
print("4. The relationship might be non-linear - try polynomial or spline models")
print("5. Spatial autocorrelation should be accounted for in any analysis")



import plotly.express as px

fig1 = px.scatter(df_planets,
                  x='log_dm_density',
                  y='pl_orbper',
                  color='mass_category',
                  size='pl_bmasse',
                  hover_data=['pl_rade', 'pl_orbper', 'pl_bmasse', 'cluster'],
                  title='Orbital Period vs Log(Dark Matter Density) by Planet Mass',
                  labels={'log_dm_density':'Log(DM Density)','pl_orbper':'Orbital Period (days)'}
                 )
fig1.update_yaxes(type='log')
fig1.show()

fig2 = px.scatter_3d(df_planets,
                     x='r_galactic',
                     y='log_dm_density',
                     z='pl_orbper',
                     color='mass_category',
                     size='pl_bmasse',
                     hover_data=['pl_rade', 'pl_orbper', 'pl_bmasse', 'cluster'],
                     title='3D: Galactic Radius vs DM Density vs Orbital Period'
                    )
fig2.update_layout(scene=dict(zaxis_type='log'))
fig2.show()

fig3 = px.box(df_planets,
              x='mass_category',
              y='pl_orbper',
              log_y=True,
              points="all",
              title="Distribution of Orbital Period by Planet Mass Category",
              labels={'pl_orbper':'Orbital Period (days)', 'mass_category':'Planet Mass Category'})
fig3.show()
